<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mir: A brief guide for versioning symbols in the Mir DSOs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mir
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">A brief guide for versioning symbols in the Mir DSOs </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>So, what do I have to do? </h2>
<p>There are more detailed descriptions below, but as a general rule:</p>
<ul>
<li>If you add a new symbol, add it to a <code>*_NEXTSERIES</code> version stanza, like <code>MIR_CLIENT_0.22</code>, <code>MIR_PLATFORM_0.22</code>, etc representing the next future Mir series in which the new symbol will first be released.</li>
<li>If you change the behaviour or signature of a symbol <em>and</em> wish to preserve backward compatibility, see "Change symbols without breaking ABI" below.</li>
</ul>
<h2>Can I have some details? </h2>
<p>Sure.</p>
<p>Mir is a set of libraries, one C++ library for writing display- server/compositor/shells and one C library for writing clients (or, more usually, toolkits for clients) that use a Mir display-server for output. Mir also has internal dynamic libraries for platform support - drivers - and may in future allow the same with extensions to the core functionality. As such, the ABI of these interfaces is important to keep in mind.</p>
<p>Mir uses the ELF symbol versioning support. This provides three advantages:</p>
<ul>
<li>Consumers of the Mir libraries can know at load time rather than symbol resolution time whether the library exposes all the symbols they expect.</li>
<li>We can drop or change the behaviour of symbols without breaking ABI by exposing multiple different implementations under different versions, and</li>
<li>We can (modulo protobuf singletons in our current implementation, and with some care) safely load multiple different versions of Mir libraries into the same process.</li>
</ul>
<h2>When should I bump SONAME? </h2>
<p>There are varying standards for when to bump SONAME. In Mir we choose to bump the SONAME of a library whenever we make a change that could cause a binary linked to the library to fail <em>as long as</em> the binary is using only public interfaces and (where applicable) relying on documented behaviour. In general, changes that make an interface work as described by its documentation will not result in SONAME bumps.</p>
<p>With that explanation, you <em>should</em> bump SONAME when:</p>
<ul>
<li>You remove a public symbol from a library</li>
<li>You change the signature of a public symbol <em>without</em> retaining the previous signature exposed under the old versioning.</li>
<li>You change the behaviour of a public symbol <em>without</em> retaining the previous behaviour exposed with the old versioning.</li>
</ul>
<p>If you are changing the behaviour of an interface, think about whether it's easy to maintain the old interface in parallel. If it is, you should consider providing both under different versions. This should become easier over time as the Mir ABI becomes more stable and also more valuable over time as the Mir libraries become more widely used.</p>
<h2>Load-time version detection </h2>
<p>When using versioned symbols the linker adds an extra, special symbol containing the version(s) exported from the library. Consumers of the library resolve this on library load. For example: </p><pre class="fragment">$ objdump -C -T lib/libmirclient.so
…
00000000002a2080  w   DO .data.rel.ro   0000000000000080  MIR_CLIENT_8 vtable for mir::client::DefaultConnectionConfiguration
0000000000000000 g    DO *ABS*  0000000000000000  MIR_CLIENT_8 MIR_CLIENT_8
0000000000030ed2 g    DF .text  0000000000000098  MIR_CLIENT_8 mir::client::DefaultConnectionConfiguration::the_rpc_report()
…
</pre><p>This shows the special <code>MIR_CLIENT_8</code> symbol of the current libmirclient, along with a versioned symbol in the read-only data segment (the vtable for <code>mir::client::DefaultConnectionConfiguration</code>) and a versioned symbol in the text segment (the implementation of <code>mir::client::DefaultConnectionConfiguration::the_rpc_report()</code>). If a client needed a symbol versioned with <code>MIR_CLIENT_9</code>, it would try to resolve this at load time and fail, rather than failing when the symbol was first referenced - possibly much later, and more confusingly.</p>
<h3>So what do I have to do to make this work?</h3>
<p>When you add new symbols, add them to a new <code>version</code> block in the relevant <code>symbols.map</code> file, like so: </p><pre class="fragment">MIR_CLIENT_0.17 {
    global:
        mir_connect_sync;
        ...
        /* Other symbols go here */
};

MIR_CLIENT_0.18 {
    global:
        mir_connect_new_symbol;
    local:
        *;
} MIR_CLIENT_0.17;
</pre><p>Note that the script is read top to bottom; wildcards are greedily bound when first encountered, so to avoid surprises you should only have a wildcard in the final stanza.</p>
<h2>Change symbols without breaking ABI </h2>
<p>ELF DSOs can have multiple implementations for the same symbol with different versions. This means that you can change the signature or behaviour of a symbol without breaking dependants that use the old behaviour. While there can be as many different implementations with different versions as you want, there can only be one default implementation - this is what the linker will resolve to when building a dependant project.</p>
<p>Binding different implementations to the versioned symbol is done with <code>__asm__</code> directives in the relevant source file(s). The default implementation is specified with <code>symbol_name@@VERSION</code>; other versions are specified with <code>symbol_name@VERSION</code>.</p>
<p>Note that this does <em>not</em> require a change in SONAME. Binaries that have been linked against the old library will continue to work and resolve to the old implementation. Binaries linked against the new library will resolve to the new (default) implementation.</p>
<h3>So, what do I have to do to make this work?</h3>
<p>For example, if you wanted to change the signature of <code>mir_connection_create_surface</code> to take a new parameter:</p>
<p><code>mir_connection_api.cpp</code>: </p><pre class="fragment">__asm__(".symver old_mir_connection_create_surface,mir_connection_create_surface@MIR_CLIENT_0.17");

extern "C" MirWaitHandle* old_mir_connection_create_surface(...)
/* The old implementation */

/* The @@ specifies that this is the default version */
__asm__(".symver mir_connection_create_surface,mir_connection_create_surface@@@MIR_CLIENT_0.18");
MirWaitHandle* mir_connection_create_surface(...)
/* The new implementation */
</pre><p><code>symbols.map</code>: </p><pre class="fragment">MIR_CLIENT_0.17 {
    global:
        ...
        mir_connection_create_surface;
        ...
};

MIR_CLIENT_0.18 {
    global:
        ...
        mir_connection_create_surface;
        ...
    local:
        *;
} MIR_CLIENT_0.17;
</pre><h2>Safely load multiple versions of a library into the same address space </h2>
<p>This benefit is currently theoretical, as there seems to be a Protobuf singleton that aborts if we try this. But should that be resolved, it's theoretically possible and of some benefit...</p>
<p>This situation will come about - the Qtmir plugin links to libmirclient and also libEGL, and libEGL will link to libmirclient itself. There is no guarantee that Qtmir and libEGL will link to the same SONAME, and so a process can end up trying to load both <code>libmirclient.so.8</code> and <code>libmirclient.so.9</code> into its address space. Without symbol versioning this is potentially broken - there's no mechanism for libEGL to only resolve symbols from <code>libmirclient.so.8</code> and Qtmir to only resolve symbols from <code>libmirclient.so.9</code>, so in cases where symbols have changed use of those symbols will break.</p>
<p>By versioning the symbols we ensure that code always gets exactly the symbol implementation it expects, even when multiple library versions are loaded.</p>
<h3>So, what do I have to do to make this work?</h3>
<p>Ensure that different implementations of a symbol have different versions.</p>
<p>Additionally there's the complication of passing objects between different versions. For the moment, we can not bother trying to make this work.</p>
<h2>See also: </h2>
<p><a href="https://sourceware.org/binutils/docs/ld/VERSION.html">Binutils manual</a></p>
<p><a href="http://www.akkadia.org/drepper/dsohowto.pdf">Former glibc maintainer's DSO guide</a> </p>
</div></div><!-- contents -->
<hr>
<p align="center">Copyright &copy; 2012-2017
 Canonical Ltd. <br />
Generated on Tue 28 Nov 14:36:47 UTC 2017
</p>
</body>
</html>
